nb haskell unicode
Current support for Unicode in source files.
http://hackage.haskell.org/trac/haskell-prime/wiki/UnicodeInHaskellSource

Jhc allows unrestricted use of the Unicode character set in Haskell
source, treating input as UTF-8.  Several uses of Unicode characters in
place of Haskell keywords are permitted:

	→ (\x2192) is equivalent to ->
	← (\x2190) is equivalent to <-
	∷ (\x2237) is equivalent to ::
	‥ (\x2025) is equivalent to ..
	⇒ (\x21d2) is equivalent to =>
	∀ (\x2200) is equivalent to forall
	∃ (\x2203) is equivalent to exists (see ExistentialQuantification)

In addition there is experimental support for defining new operators and
names using various Unicode characters.

Hugs treats input as being in the encoding specified by the current locale,
but permits Unicode only in comments and character and string literals.

GHC now (as of early Jan 2006) interprets source files as UTF-8.
In -fglasgow-exts mode the above special symbols are interpreted as in JHC.
GHC knows about the characters classifications of all unicode characters
via the Data.Char library, and can therefore understand identifiers
written using alphanumeric characters from any language (but see below
for note about caseless character sets).

Others treat source code as ISO 8858-1 (Latin-1).


nb ghc unicode syntax option
Unicode syntax
http://haskell.org/ghc/docs/6.12.2/html/users_guide/syntax-extns.html

The language extension -XUnicodeSyntax enables Unicode characters to be
used to stand for certain ASCII character sequences.  The following
alternatives are provided:

ASCII	Unicode alternative	Code point	Name
::	::	0x2237	PROPORTION
=>	⇒	0x21D2	RIGHTWARDS DOUBLE ARROW
forall	∀	0x2200	FOR ALL
->	→	0x2192	RIGHTWARDS ARROW
<-	←	0x2190	LEFTWARDS ARROW
..	…	0x22EF	MIDLINE HORIZONTAL ELLIPSIS


nb haskell define use new operator @rwhbook
RWH pp. 225–226

> module UniOp where

=? includes both equality (=) and test (?).

This usage of "=" in these "C-syntax" languages can lead to coding errors.
A programmer may mistype "if (x = y)" instead of "if (x == y)".
In C, the former code fragment roughly means "assign y to x, and if the
new value of x is not zero, execute the statement following".
The latter code fragment roughly means "if and only if x is equal to y,
execute the statement following".¹
 ¹ http://en.wikipedia.org/wiki/Relational_operator

> (=?) :: (Eq a) ⇒ a → a → Bool
> (=?) = (==)
> infix 4 =?

Multiplication is often written using the multiplication sign "×" … in
infix notation.  ….  Multiplication is sometimes denoted by either a
middle dot "·" or a period.  ….  The asterisk (as in 5*2) is often used
in programming languages because it appears on every keyboard ….  This
usage originated in the FORTRAN programming language.¹
 ¹ http://en.wikipedia.org/wiki/Multiply#Notation_and_terminology

> (·) :: (Num a) ⇒ a → a → a
> (·) = (*)
> infixl 7 ·

> (×) :: (Num a) ⇒ a → a → a
> (×) = (*)
> infixl 7 ×

The obelus was first used as a symbol for division in 1659 in the algebra
book /Teutsche Algebra/ by Johann Rahn.  Some think that John Pell, who
edited the book, may have been responsible for this use of the symbol.
The obelus had been used by some writers to represent subtraction,
and that usage continued in some parts of Europe (including Norway and,
until fairly recently, Denmark).  ….  The obelus is used primarily as a
symbol for division (as on a calculator) and as an operator in
elementary arithmetic.  ….  In the Unicode character set, the obelus is
known as the “division sign” and has the code point U+00F7.¹
 ¹ http://en.wikipedia.org/wiki/Obelus

> (÷) :: (Fractional a) ⇒ a → a → a
> (÷) = (/)
> infixl 7 ÷

In expressions such as a^{b}, the notation for exponentiation is usually
to write the exponent b as a superscript to the base number a.  But many
environments—such as programming languages and plain-text e-mail—do not
support such two-dimensional layout.  People have adopted the linear
notation a↑b for such environments; the up-arrow suggests 'raising to
the power of'.  If the character set doesn't contain an up arrow, the
caret ^ is used instead.  The superscript notation a^{b} doesn't lend
itself well to generalization, which explains why Knuth chose to work
from the inline notation a↑b instead.¹
 ¹ http://en.wikipedia.org/wiki/Knuth's_up-arrow_notation

> (↑) :: (Num a, Integral b) => a -> b -> a
> (↑) = (^)
> infixr 8 ↑

The Unicode minus sign is designed to be the same length and height as
the plus and equals signs.  In most fonts these are the same width as
digits in order to facilitate the alignment of numbers in tables.  The
hyphen-minus sign (-) is the ASCII version of the minus sign, and
doubles as a hyphen.  It is usually shorter in length than the plus sign
and sometimes at a different height.  It can be used as a substitute for
the true minus sign when the character set is limited to ASCII.¹
 ¹ http://en.wikipedia.org/wiki/Minus#Character_codes

> (−) :: (Num a) ⇒ a -> a -> a
> (−) = (-)
> infixl 6 −

In print ≠, meaning not equal to, tests the negated equivalence of two values.¹
 ¹ http://en.wikipedia.org/wiki/Relational_operator

> (≠) :: (Eq a) ⇒ a → a → Bool
> (≠) = (/=)
> infix 4 ≠

And is usually expressed with an infix operator.  In mathematics and
logic, it is usually ∧; in electronics ·; and in programming languages,
& or and.  Some programming languages have a related control structure,
the short-circuit and, written &&, and then, etc.¹
 ¹ http://en.wikipedia.org/wiki/Logical_conjunction

Reserve ∧ for bitwise operations, after the weight of ⊻.

> (⋀) :: Bool → Bool → Bool
> (⋀) = (&&)
> infixr 3 ⋀

Or is usually expressed with an infix operator.  In mathematics and
logic, it is usually ∨; in electronics, +; and in programming languages,
| or or.  Some programming languages have a related control structure,
the short-circuit or, written ||, or else, etc.¹
 ¹ http://en.wikipedia.org/wiki/Logical_disjunction

Reserve ∨ for bitwise operations, after the weight of ⊻.

> (⋁) :: Bool → Bool → Bool
> (⋁) = (||)
> infixr 2 ⋁

In print ≥, meaning greater than or equal to, tests if the value of the
left expression is greater than or equal to that of the right.¹
 ¹ http://en.wikipedia.org/wiki/Relational_operator

> (≥) :: (Ord a) ⇒ a → a → Bool
> (≥) = (>=)
> infix 4 ≥

In print ≤, meaning less than or equal to, tests if the value of the
left expression is less than or equal to that of the right.¹
 ¹ http://en.wikipedia.org/wiki/Relational_operator

> (≤) :: (Ord a) ⇒ a → a → Bool
> (≤) = (<=)
> infix 4 ≤
