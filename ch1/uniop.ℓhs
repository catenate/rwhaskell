nb haskell unicode
Current support for Unicode in source files.
http://hackage.haskell.org/trac/haskell-prime/wiki/UnicodeInHaskellSource

Jhc allows unrestricted use of the Unicode character set in Haskell
source, treating input as UTF-8.  Several uses of Unicode characters in
place of Haskell keywords are permitted:

	→ (\x2192) is equivalent to ->
	← (\x2190) is equivalent to <-
	∷ (\x2237) is equivalent to ::
	‥ (\x2025) is equivalent to ..
	⇒ (\x21d2) is equivalent to =>
	∀ (\x2200) is equivalent to forall
	∃ (\x2203) is equivalent to exists (see ExistentialQuantification)

In addition there is experimental support for defining new operators and
names using various Unicode characters.

Hugs treats input as being in the encoding specified by the current locale,
but permits Unicode only in comments and character and string literals.

GHC now (as of early Jan 2006) interprets source files as UTF-8.
In -fglasgow-exts mode the above special symbols are interpreted as in JHC.
GHC knows about the characters classifications of all unicode characters
via the Data.Char library, and can therefore understand identifiers
written using alphanumeric characters from any language (but see below
for note about caseless character sets).

Others treat source code as ISO 8858-1 (Latin-1).


nb ghc unicode syntax option
Unicode syntax
http://haskell.org/ghc/docs/6.12.2/html/users_guide/syntax-extns.html

The language extension -XUnicodeSyntax enables Unicode characters to be
used to stand for certain ASCII character sequences.  The following
alternatives are provided:

ASCII	Unicode alternative	Code point	Name
::	::	0x2237	PROPORTION
=>	⇒	0x21D2	RIGHTWARDS DOUBLE ARROW
forall	∀	0x2200	FOR ALL
->	→	0x2192	RIGHTWARDS ARROW
<-	←	0x2190	LEFTWARDS ARROW
..	…	0x22EF	MIDLINE HORIZONTAL ELLIPSIS


nb haskell define use new operator @rwhbook
RWH pp. 225–226

> module UniOp where

=? includes both equality (=) and test (?).

This usage of "=" in these "C-syntax" languages can lead to coding errors.
A programmer may mistype "if (x = y)" instead of "if (x == y)".
In C, the former code fragment roughly means "assign y to x, and if the
new value of x is not zero, execute the statement following".
The latter code fragment roughly means "if and only if x is equal to y,
execute the statement following".¹
 ¹ http://en.wikipedia.org/wiki/Relational_operator

> (=?) :: (Eq a) ⇒ a → a → Bool
> (=?) = (==)
> infix 4 =?

In print ≠, meaning not equal to, tests the negated equivalence of two values.¹
 ¹ http://en.wikipedia.org/wiki/Relational_operator

> (≠) :: (Eq a) ⇒ a → a → Bool
> (≠) = (/=)
> infix 4 ≠

And is usually expressed with an infix operator.  In mathematics and
logic, it is usually ∧; in electronics ·; and in programming languages,
& or and.  Some programming languages have a related control structure,
the short-circuit and, written &&, and then, etc.¹
 ¹ http://en.wikipedia.org/wiki/Logical_conjunction

Reserve ∧ for bitwise operations, after the weight of ⊻.

> (⋀) :: Bool → Bool → Bool
> (⋀) = (&&)
> infixr 3 ⋀

Or is usually expressed with an infix operator.  In mathematics and
logic, it is usually ∨; in electronics, +; and in programming languages,
| or or.  Some programming languages have a related control structure,
the short-circuit or, written ||, or else, etc.¹
 ¹ http://en.wikipedia.org/wiki/Logical_disjunction

Reserve ∨ for bitwise operations, after the weight of ⊻.

> (⋁) :: Bool → Bool → Bool
> (⋁) = (||)
> infixr 2 ⋁

In print ≥, meaning greater than or equal to, tests if the value of the
left expression is greater than or equal to that of the right.¹
 ¹ http://en.wikipedia.org/wiki/Relational_operator

> (≥) :: (Ord a) ⇒ a → a → Bool
> (≥) = (>=)
> infix 4 ≥

In print ≤, meaning less than or equal to, tests if the value of the
left expression is less than or equal to that of the right.¹
 ¹ http://en.wikipedia.org/wiki/Relational_operator

> (≤) :: (Ord a) ⇒ a → a → Bool
> (≤) = (<=)
> infix 4 ≤
